

## 专业课基础复习

### 1. C++面向对象

#### 构造函数

创造并初始成员变量(member variables)，并为虚函数创造虚函数表(virtual tables)。

默认构造函数(default constructor)：没有形参或所有形参(parameter)有默认值

复制构造函数(copy constructor)：通过浅拷贝的方式用另一个相同类的不同对象初始化对象的成员变量。若不自己写，编译器自动提供。



何时调用复制构造函数：

1) 函数通过值返回一个对象

2) 通过值作为形参传递对象

3) 通过其他对象创建对象

4) 编译器产生临时变量



编译器默认提供的类函数：默认构造函数；拷贝构造函数；析构函数；赋值函数(assignment operator)；取地址符(address operator)

转换构造函数(conversion constructor)：构造函数、有且仅有一个参数、参数类型是基本类型或者其他类类型

类型转换函数(conversion operator)：

```
operator int ()  // 重载int类型转换函数
{
return mValue;
}
```



#### 重载和重写

（overload / override）

方法重载是指同一个命名空间中的多个方法具有相同的名字,但这些方法具有不同的参数列表(Argument list),即参数的数量或参数类型(Argument lists)不能完全相同，即使返回类型不同(return type)

方法重写是存在子父类之间的,子类定义的方法与父类中的方法具有相同的方法名字,相同的参数表和相同的返回类型 (same method name/ data type/ argument list)
​      注: 
​        (1)子类中不能重写父类中的final方法 
​        (2)子类中必须重写父类中的abstract方法 



#### 多态

polymorphism

1.静态多态（函数重载+泛型编程）

静态多态是编译器在编译期间完成的，编译器会根据实参类型来选择调用合适的函数，如果有合适的函数可以调用就调，没有的话就会发出警告或者报错



2.动态多态（虚函数）

它是在**程序运行时**根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的虚函数。

**动态多态的条件：** 
1) 基类中必须包含虚函数，并且派生类中一定要对基类中的虚函数进行**重写**(override)。 
2) 通过基类对象的指针或者引用调用虚函数。



**总结一道面试题：**那些函数不能定义为虚函数？ 
经检验下面的几个函数都不能定义为虚函数： 
1）友元函数，它不是类的成员函数 
2）全局函数 
3）静态成员函数，它没有this指针 
3）构造函数，拷贝构造函数，以及赋值运算符重载（可以但是一般不建议作为虚函数）



#### 虚函数

virtual function

作用：实现多态机制

实现：虚函数表（virtual table）。表中存放一个类的虚函数地址，存储于类的实例中最前面的位置。

基类指针指向基类对象，那调用的是基类虚函数；指向子类对象，那就调用子类虚函数。因为在定义基类或子类对象时，就将虚函数与该类绑定了。



析构函数为什么要用虚函数：C++中基类采用virtual析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。

#### new和malloc

2.1 属性

    new和delete是C++关键字，需要编译器支持；malloc和free是库函数(library funtion)，需要头文件(header file)支持。

2.2 参数

    使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式(explicitly)地指出所需内存的大小。

2.3 返回类型

    new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换(type cast)将void*指针转换成我们需要的类型。

2.4 自定义类型


    new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。
    malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

2.5 重载

    C++允许重载new/delete操作符，malloc不允许重载。

2.6 内存区域

    new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。

2.7 分配失败

    new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。

2.8 内存泄漏

    内存泄漏对于new和malloc都能检测出来，而new可以指明是哪个文件的哪一行，malloc确不可以。



### 2. 数据结构

#### 堆

一棵完全二叉树（complete binary tree)

最小堆：任何非叶节点都小于它的子节点

建堆：Filterdown算法，取序列最右边的分支节点自下而上，复杂度O(nlogn)

#### 堆排序

1.构造最大堆

2.输出堆顶元素，调整剩余元素（Filterdown）

3.不断重复直至全部调整完毕。

#### 二分查找/排序树

定义：

1.左子树上所有节点小于根节点的关键字

2.右子树大于

3.左子树和右子树也是二叉排序树

特点：

中序遍历得到顺序序列

查找复杂度log（n）

输入顺序不同会导致树形状不同

当退化为单支树时，复杂度为O（(n+1)/2))

#### 数组和链表

不同：链表是链式的存储结构；数组是顺序的存储结构。

链表通过指针来连接元素与元素，数组则是把所有元素按次序依次存储。

链表的插入删除元素相对数组较为简单，不需要移动元素，且较为容易实现长度扩充，但是寻找某个元素较为困难；

数组寻找某个元素较为简单，但插入与删除比较复杂，由于最大长度需要再编程一开始时指定，故当达到最大长度时，扩充长度不如链表方便。
相同：两种结构均可实现数据的顺序存储，构造出来的模型呈线性结构。



### 3. 网络

#### 模型

##### OSI

物理层、数据链路层、网络层、传输层、对话层、表示层和应用层

第一层:物理层(Physical Layer)

规定通信设备的机械的、电气的、功能的和规程的特性，用以建立、维护和拆除物理链路连接。具体地讲，机械特性定了网络连接时所需接插件的规格尺寸、引脚数量和排列情况等;电气特性规定了在物理连接上传输bit流时线路上信号电平的大小、阻抗匹配、传输速率距离限制等;功能特性是指对各个信号先分配确切的信号含义，即定义了DTE和DCE之间各个线路的功能;规程特性定义了利用信号线进行bit流传输的一组操作规程，是指在物理连接的建立、维护、交换信息时，DTE和DCE双方在各电路上的动作系列。

在这一层，数据的单位称为比特(bit)。物理层的主要设备:中继器、集线器、适配器。

第二层:数据链路层(DataLink Layer)

物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧(Frame)在信道上无差错的传输，并进行各电路上的动作系列。

数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括:物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。

在这一层，数据的单位称为帧(frame)。

主要设备:二层交换机、网桥。

第三层:网络层(Networklayer)

在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点，确保数据及时传送。网络层将数据链路层提供的帧组成数据包，包中封装有网络层包头，其中含有逻辑地址信息- -源站点和目的站点地址的网络地址。

如果你在谈论一个IP地址，那么你是在处理第3层的问题，这是”数据包”问题，而不是第2层的”帧”。IP是第3层问题的一部分，此外还有一些路由协议和地址解析协议(ARP)。有关路由的一切事情都在第3层处理。地址解析和路由是3层的重要目的。网络层还可以实现拥塞控制、网际互连等功能。

在这一层，数据的单位称为数据包(packet)。

网络层协议的代表包括:IP、IPX、RIP、ARP、RARP、OSPF等。

网络层主要设备:路由器

第四层:传输层(Transportlayer)

第4层的数据单元也称作处理信息的传输层(Transport layer)。但是，当你谈论TCP等具体的协议时又有特殊的叫法，TCP的数据单元称为段(segments)而UDP协议的数据单元称为”数据报(datagrams)”。这个层负责获取全部信息，因此，它必须跟踪数据单元碎片、乱序到达的数据包和其它在传输过程中可能发生的危险。第4层为上层提供端到端(最终用户到最终用户)的透明的、可靠的数据传输服务。所谓透明的传输是指在通信过程中传输层对上层屏蔽了通信传输系统的具体细节。

传输层协议的代表包括:TCP、UDP、SPX等。

第五层:会话层(Sessionlayer)

在会话层及以上的高层次中，数据传送的单位不再另外命名，统称为报文。会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。如服务器验证用户登录便是由会话层完成的。

第六层:表示层(Presentationlayer)

这一层主要解决用户信息的语法表示问题。它将欲交换的数据从适合于某一用户的抽象语法，转换为适合于OSI系统内部使用的传送语法。即提供格式化的表示和转换数据服务。数据的压缩和解压缩， 加密和解密等工作都由表示层负责。例如图像格式的显示，就是由位于表示层的协议来支持。

第七层:应用层(Application Layer)

应用层为操作系统或网络应用程序提供访问网络服务的接口。

应用层协议的代表包括:Telnet、FTP、HTTP、SNMP等。



应用层:提供用户与网络间的接口。----HTTP、FTP、SMTP

运输层:进程到进程间的数据传输。---TCP、UDP

网络层:主机到主机之间的数据传输。---IP、选路协议

数据链路层:相邻结点之间的数据传输。---PPP、以太网

物理层:在物理介质上传输比特流。

应用层---------PDU是报文(message)
传输层---------PDU是数据段(segment)
网络层---------PDU是数据报(datagram)
数据链路层-----PDU是数据帧(frame)
物理层---------PDU是比特(bit)



#### 三次握手/四次挥手

![img](https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=2590032753,2466318043&fm=173&app=49&f=JPEG?w=640&h=716&s=E7F239D247AFCCEA106594580300D072)

#### DNS域名解析

应用层中的两种软件：

1. 客户/服务器
2. P2P体系结构

域名结构：

```http
mail.cctv.com
(三级域名).(二级域名).(顶级域名)
```

域名服务器：

1. 根域名服务器：最高层次的服务器，当任意一个本地域名服务器无法对一个域名进行解析，就求助于根域名服务器。它告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询。
2. 顶级域名服务器(TLD)：管理其下的所有二级域名。收到DNS查询请求时，就给出相应的回答。
3. 权限域名服务器：负责一个区的域名服务器，当权限域名服务器不能给出最后查询的回答时，就会告诉发出查询请求的DNS客户，下一步应当找哪一个权限域名服务器。
4. 本地域名服务器：当一台主机发出DNS查询请求时，这个查询请求就会发报文给本地域名服务器。其距离用户比较近。
5. 为了提高域名服务器的可靠性，将数据复制到几个域名服务器存储。一个是主域名服务器，其他是辅助域名服务器。修改只能通过主域名服务器进行。



##### 域名解析过程：

1. 通过域名访问网页
2. 计算机会先将域名发送到一个解析域名的服务器上
   1. 在其服务器上有很多服务器，能解析各种各样的域名，比如有专门解析.org的，解析.com的，解析.net的。等等，最主要的有一个根域名服务器，
   2. 域名解析(在服务器上查找IP地址)的过程有两种算法，迭代查询，递归查询。一般是两种查询的结合
   3. 本机计算机找到其中一台解析域名的服务器(可能是.com)，如果没有找到对应的IP地址，那么就会去找根域名服务器，根域名服务器知道所有的子服务器，所以他肯定知道该域名所对应的IP地址在那个子服务器中，所以告诉第一次查询的服务器要他去另一台服务器上找，找到了，就将其返回给计算机，以后再有另一台计算机也通过这个域名访问，那么该服务器会有原来的域名IP地址的**缓存**，就不用去找根服务器了。



*主机像本地域名服务器的查询一般采用**递归查询**，本地域名服务器向根域名服务器的查询通常采用**迭代查询**。

案例：查询y.abc.com的IP地址。

- 主机向本地域名服务器dns.xyz.com递归查询
- 本地域名服务器采用迭代查询。先向一个根域名服务器查询。
- 根域名服务器告诉本地域名服务器，下一次应查询的顶级域名服务器dns.com的IP地址。
- 本地域名服务器向顶级域名服务器dns.com查询。
- 顶级域名服务器dns.com告诉本地域名服务器，一下次应查询的权限域名服务器dns.abc.com的IP。
- 本地域名服务器向权限域名服务器dns.abc.com查询。
- 权限域名服务器dns.abc.com告诉本地域名服务器，所查询的主机的IP。
- 本地域名服务器把查询结果告诉主机。





#### HTTP协议

##### 统一资源定位符URL

```http
http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#r_70732423
```

一个完整的URL包括：协议部分、域名部分、端口部分、虚拟目录部分、文件名部分、参数部分、锚部分

1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符

2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用

3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口

4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”

5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名

7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。

6.锚部分：HTTP请求不包括锚部分，从“#”开始到最后，都是锚部分。本例中的锚部分是“r_70732423“。锚部分也不是一个URL必须的部分。 
锚点作用：打开用户页面时滚动到该锚点位置。

例：

一个域名“www.baidu.com.”由4部分：第1部分“.”代表根服务器、第2部分“.com.”代表顶级域名服务器、第3部分“baidu.com.”代表域名所有者服务器、第4部分“www.baidu.com.”代表主机域名。



##### 超文本传输协议HTTP

作用：怎样向服务器请求文档、服务器怎么把文档传送给浏览器，通俗点讲，就是我们想服务器访问网页资源时，服务器如何把网页上的东西传给我们。

客户端向服务器：请求报文　　　　服务器向客户端：响应报文

什么意思呢？在通过URL访问你服务器时，就会发送一个请求报文，告诉服务器需要哪些东西，服务器知道后，返回一个响应报文给客户端，其中就会带有一些网页信息。就是通过这个来达到传送网页资源的目的，现在来具体看看，请求报文和响应报文的格式。

请求报文格式：

![img](https://images2015.cnblogs.com/blog/874710/201612/874710-20161204145318443-858755785.png)

请求报文：

![img](https://images2015.cnblogs.com/blog/874710/201612/874710-20161204143934162-589996618.png)

请求头：

1、GET：请求的方式

2、Host：主机名 www.solu.com　　　　　　

3、User-Agent：使用什么代理服务器，这里就是FireFox，也就是火狐

4、Accept：能接收的数据类型有哪些

5、Accept-Language：表示用户希望优先想得到的版本，一次排列下去，先是中文，再是英文

6、Accept-Encoding：通知服务端可以发送的数据压缩格式

7、Cookie：浏览器端的一个技术，在服务器上记录用户信息，但是也会在浏览器中保存一份。

8、Connection：连接的方式，有两种，非持续连接和持续连接，非持续连接，一次请求/响应就对应一个TCP连接，接到了响应该连接就关闭，然后在发送请求就在建立TCP连接，持续连接就相反，这里使用的是持续连接

9、Upgrade-Insecure-Requests：该指令用于让浏览器自动升级请求从http到https,用于大量包含http资源的http网页直接升级到https而不会报错.简洁的来讲,就相当于在http和https之间起的一个过渡作用（了解即可）



##### 状态码：

- 1xx：表示通知信息的，比如请求收到了或正在进行处理
- 2xx：表示成功，也就是服务器接收到了你的请求，并成功处理了，一般最喜欢看到的就是200了
- 3xx：表示重定向，服务器告诉浏览器要完成请求你必须采取进一步的行动，也就是去访问另一个网页，
- 4xx：表示客户的差错，比如请求中有错误的语法或不能完成
  - 400错误：Bad request。提交的参数与后端不符或前端没将后端所传的json数据转化为字符串。
  - 404错误：就是找不到资源，就是你的URL写的有错误，使定位不到正确的资源
  - 405：方法不被允许，访问了不该访问的资源。
- 5xx：服务器的差错，如服务器失效，或者内部出现异常不能完成你的请求
  - 500：就是服务器写的代码中有问题。
  - 502：bad gateway，网关错误。后端不可响应或响应超时(mysql过慢等)
  - 504：被请求服务器发送超时引起。

##### HTTP&HTTPS：

Https：是以安全为目标的Http通道，是Http的安全版。Https的安全基础是SSL。SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层：SSL记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL握手协议（SSL Handshake Protocol），它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。

区别：

1、https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。(原来网易官网是http，而网易邮箱是https。)

2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

4、http的连接很简单，是无状态的。Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

HTTPS优点：

1、使用Https协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。

2、Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。

3、Https是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

HTTPS缺点：

1、Https协议握手阶段比较费时，会使页面的加载时间延长近。

2、Https连接缓存不如Http高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响；

3、SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。

4、Https协议的加密范围也比较有限。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。

##### 从输入URL到页面展示的详细过程

- 1、输入网址
- 2、DNS解析
- 3、建立tcp连接
- 4、客户端发送HTPP请求
- 5、服务器处理请求
- 6、服务器响应请求
- 7、浏览器展示HTML
- 8、浏览器发送请求获取其他在HTML中的资源。

##### Session&Cookie

由于http的无状态性，为了使某个域名下的所有网页能够共享某些数据，session和cookie出现了。客户端访问服务器的流程如下

- 首先，客户端会发送一个http请求到服务器端。
- 服务器端接受客户端请求后，建立一个session，并发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。该头部包含了sessionId。Set-Cookie格式如下，具体请看[Cookie详解](http://bubkoo.com/2014/04/21/http-cookies-explained/)
  `Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]`
- 在客户端发起的第二次请求，假如服务器给了set-Cookie，浏览器会自动在请求头中添加cookie
- 服务器接收请求，分解cookie，验证信息，核对成功后返回response给客户端

![è¯·æ±æµç¨](https://segmentfault.com/img/bVbmYbQ?w=400&h=200)

##### 注意

- cookie只是实现session的其中一种方案。虽然是最常用的，但并不是唯一的方法。禁用cookie后还有其他方法存储，比如放在url中
- 现在大多都是Session + Cookie，但是只用session不用cookie，或是只用cookie，不用session在理论上都可以保持会话状态。可是实际中因为多种原因，一般不会单独使用
- 用session只需要在客户端保存一个id，实际上大量数据都是保存在服务端。如果全部用cookie，数据量大的时候客户端是没有那么多空间的。
- 如果只用cookie不用session，那么账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露。并且客户端数据量变大，网络传输的数据量也会变大



### 4. OS

#### 进程与线程

process and thread

- 进程是资源分配的最小单位，线程是程序执行的最小单位。
- 进程有自己的独立地址空间(address space)，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
- 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。
- 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器（双CPU系统）上运行。

进程执行开销大，但是能够很好的进行资源管理和保护。进程可以跨机器前移。



对资源的管理和保护要求高，不限制开销和效率时，使用多进程。

要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。

#### 死锁

概念：多个并发进程因争夺系统资源而产生相互等待的现象。

原理：当一组进程中的每个进程都在等待某个事件发生，而只有这组进程中的其他进程才能触发该事件，这就称这组进程发生了死锁。

本质原因：
​        1) 系统资源有限。
​        2) 进程推进顺序不合理。

死锁产生的4个必要条件
​    1、互斥：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。
​    2、占有且等待：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。
​    3、不可抢占：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。

​    4、循环等待：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。

#### 进程通信

1. 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
2. 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
3. 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
4. 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
5. 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
6. 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
7. 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

#### 多线程

和单道程序一样，同一时刻也是只能一个程序占据一颗cpu（多核CPU）。但是和单道程序不同的是，当该程序等待其他资源的时候，它就放弃cpu或者当一个设定的时间到了放弃cpu，让其他程序拥有cpu。该程序不可能一直占据，如此这就避免了cpu空等的情况，让cpu始终有程序运行。因为程序不是一直从开始执行到结束，而是中间走走停停，那就并发问题就会出现。因为当他停止的时候，它所拥有的资源或者它所需要的资源可能会被其他程序修改，这就影响程序运行的正确性。

#### 并发和并行

（1）并行是指两个或者多个事件在**同一时刻**发生；而并发是指两个或多个事件在同一时间间隔发生。

（2）并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。

并发：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。

并行：在操作系统中，一组程序按独立异步的速度执行，无论从微观还是宏观，程序都是一起执行的。



#### mutex/semaphore

 1：semaphore（信号量）范围比较广，semaphore可能会有多个属性值。比如常见的生产者和消费者问题，就是多元信号量的一种。生产者可以生产多个元素，消费者可以消费的元素必须小于生产者的生产元素个数。从此也可以看出，semaphore是允许多个线程进入，访问互斥资源。除了多元信号量之外，还存在一种二元信号量。即只存在是与否，0与1两种状态。

2：mutex（互斥量）也是一种二元的锁机制，只有是（1）和否（0）的两个值，和二元信号量比较相似。但是它和二元信号量不同的是，占有和释放必须是同一个线程。比如互斥量M被线程A占有，那么释放的时候肯定也是A线程释放的。二元信号量则不必如此，一个二元信号量的占有和释放可以是不同线程。相应的内容也可以移步看一下wiki解释--Synchronization 。mutex是可以用于进程也可以用于线程的同步机制。



### 5. DB

#### 主键



#### 外键



#### 索引

主键索引并不是聚集索引。

聚集索引：聚集索引一个表只能有一个。聚集索引存储记录是物理上连续存在，和表的物理排列顺序是一样的。

非聚集索引：一个表可有多个非聚集索引。索引顺序和数据库表的排列顺序是不一样的。

| 动作描述                   | 使用聚集索引 | 使用非聚集索引 |
| -------------------------- | ------------ | -------------- |
| 外键列                     | 应           | 应             |
| 主键列                     | 应           | 应             |
| 列经常被分组排序(order by) | 应           | 应             |
| 返回某范围内的数据         | 应           | 不应           |
| 小数目的不同值             | 应           | 不应           |
| 大数目的不同值             | 不应         | 应             |
| 频繁更新的列               | 不应         | 应             |
| 频繁修改索引列             | 不应         | 应             |
| 一个或极少不同值           | 不应         | 不应           |

#### join

inner join：

```sql
SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s
RIGHT OUTER JOIN classes c
ON s.class_id = c.id;
```

解释：INNER JOIN只返回同时存在于两张表的行数据

outer join:

```sql
SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s
RIGHT OUTER JOIN classes c
ON s.class_id = c.id;
```

解释：把两张表的所有记录全部选择出来，并且，自动把对方不存在的列填充为NULL：



left join:

解释：LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一行，并添加class_id=5，由于classes表并不存在id=5的行，所以，LEFT OUTER JOIN的结果会增加一行，对应的`class_name`是`NULL`

right join:

解释：RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以`NULL`填充剩下的字段。



#### 并发





### 6. 程序设计

#### 栈溢出

栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致栈中与其相邻的变量的值被改变。

栈溢出的前提：

1. 程序必须向栈上写入数据。
2. 写入的数据大小没有被良好地控制。





### 摩根电面

##### self intro

##### ten Questions

1) normal sorting

2) heap sort

3) reference

4) virtual function

5) abstract  class

6) stack overflow

7) several types of join in sql

8) index

9) deadlock

10) SQL injection

##### Talk about Projects

##### Q&A


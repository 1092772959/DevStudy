

## 专业课基础复习

### 1. C++面向对象

#### 构造函数

创造并初始成员变量(member variables)，并为虚函数创造虚函数表(virtual tables)。

默认构造函数(default constructor)：没有形参或所有形参(parameter)有默认值

复制构造函数(copy constructor)：通过浅拷贝的方式用另一个相同类的不同对象初始化对象的成员变量。若不自己写，编译器自动提供。



何时调用复制构造函数：

1) 函数通过值返回一个对象

2) 通过值作为形参传递对象

3) 通过其他对象创建对象

4) 编译器产生临时变量



编译器默认提供的类函数：默认构造函数；拷贝构造函数；析构函数；赋值函数(assignment operator)；取地址符(address operator)

转换构造函数(conversion constructor)：构造函数、有且仅有一个参数、参数类型是基本类型或者其他类类型

类型转换函数(conversion operator)：

```
operator int ()  // 重载int类型转换函数
{
return mValue;
}
```



#### 重载和重写

（overload / override）

方法重载是指同一个命名空间中的多个方法具有相同的名字,但这些方法具有不同的参数列表(Argument list),即参数的数量或参数类型(Argument lists)不能完全相同，即使返回类型不同(return type)

方法重写是存在子父类之间的,子类定义的方法与父类中的方法具有相同的方法名字,相同的参数表和相同的返回类型 (same method name/ data type/ argument list)
​      注: 
​        (1)子类中不能重写父类中的final方法 
​        (2)子类中必须重写父类中的abstract方法 



#### 多态

polymorphism

1.静态多态（函数重载+泛型编程）

静态多态是编译器在编译期间完成的，编译器会根据实参类型来选择调用合适的函数，如果有合适的函数可以调用就调，没有的话就会发出警告或者报错



2.动态多态（虚函数）

它是在**程序运行时**根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的虚函数。

**动态多态的条件：** 
1) 基类中必须包含虚函数，并且派生类中一定要对基类中的虚函数进行**重写**(override)。 
2) 通过基类对象的指针或者引用调用虚函数。



**总结一道面试题：**那些函数不能定义为虚函数？ 
经检验下面的几个函数都不能定义为虚函数： 
1）友元函数，它不是类的成员函数 
2）全局函数 
3）静态成员函数，它没有this指针 
3）构造函数，拷贝构造函数，以及赋值运算符重载（可以但是一般不建议作为虚函数）



#### 虚函数

virtual function

作用：实现多态机制

实现：虚函数表（virtual table）。表中存放一个类的虚函数地址，存储于类的实例中最前面的位置。

基类指针指向基类对象，那调用的是基类虚函数；指向子类对象，那就调用子类虚函数。因为在定义基类或子类对象时，就将虚函数与该类绑定了。



析构函数为什么要用虚函数：C++中基类采用virtual析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。

#### new和malloc

2.1 属性

    new和delete是C++关键字，需要编译器支持；malloc和free是库函数(library funtion)，需要头文件(header file)支持。

2.2 参数

    使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式(explicitly)地指出所需内存的大小。

2.3 返回类型

    new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换(type cast)将void*指针转换成我们需要的类型。

2.4 自定义类型


    new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。
    malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

2.5 重载

    C++允许重载new/delete操作符，malloc不允许重载。

2.6 内存区域

    new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。

2.7 分配失败

    new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。

2.8 内存泄漏

    内存泄漏对于new和malloc都能检测出来，而new可以指明是哪个文件的哪一行，malloc确不可以。



### 2. 数据结构

#### 堆

一棵完全二叉树（complete binary tree)

最小堆：任何非叶节点都小于它的子节点

建堆：Filterdown算法，取序列最右边的分支节点自下而上，复杂度O(nlogn)

#### 堆排序

1.构造最大堆

2.输出堆顶元素，调整剩余元素（Filterdown）

3.不断重复直至全部调整完毕。

#### 二分查找/排序树

定义：

1.左子树上所有节点小于根节点的关键字

2.右子树大于

3.左子树和右子树也是二叉排序树

特点：

中序遍历得到顺序序列

查找复杂度log（n）

输入顺序不同会导致树形状不同

当退化为单支树时，复杂度为O（(n+1)/2))

#### 数组和链表

不同：链表是链式的存储结构；数组是顺序的存储结构。

链表通过指针来连接元素与元素，数组则是把所有元素按次序依次存储。

链表的插入删除元素相对数组较为简单，不需要移动元素，且较为容易实现长度扩充，但是寻找某个元素较为困难；

数组寻找某个元素较为简单，但插入与删除比较复杂，由于最大长度需要再编程一开始时指定，故当达到最大长度时，扩充长度不如链表方便。
相同：两种结构均可实现数据的顺序存储，构造出来的模型呈线性结构。







### 5. DB

#### 主键



#### 索引

B+树或哈希实现

主键索引并不是聚集索引。

聚集索引：聚集索引一个表只能有一个。聚集索引存储记录是物理上连续存在，和表的物理排列顺序是一样的。

非聚集索引：一个表可有多个非聚集索引。索引顺序和数据库表的排列顺序是不一样的。

| 动作描述                   | 使用聚集索引 | 使用非聚集索引 |
| -------------------------- | ------------ | -------------- |
| 外键列                     | 应           | 应             |
| 主键列                     | 应           | 应             |
| 列经常被分组排序(order by) | 应           | 应             |
| 返回某范围内的数据         | 应           | 不应           |
| 小数目的不同值             | 应           | 不应           |
| 大数目的不同值             | 不应         | 应             |
| 频繁更新的列               | 不应         | 应             |
| 频繁修改索引列             | 不应         | 应             |
| 一个或极少不同值           | 不应         | 不应           |

建索引需要注意的问题：

创建索引：对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。

复合索引：

比如有一条语句是这样的：

```sql
select * from users where area='beijing'  and age=22;
```


​	如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age,salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为**最佳左前缀特性**。因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。

索引不要包含有NULL值的列
　　只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。

使用短索引
　　对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。

排序的索引问题
　　mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order_by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。

#### join

inner join：

```sql
SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s
RIGHT OUTER JOIN classes c
ON s.class_id = c.id;
```

解释：INNER JOIN只返回同时存在于两张表的行数据

outer join:

```sql
SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s
RIGHT OUTER JOIN classes c
ON s.class_id = c.id;
```

解释：把两张表的所有记录全部选择出来，并且，自动把对方不存在的列填充为NULL：



left join:

解释：LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一行，并添加class_id=5，由于classes表并不存在id=5的行，所以，LEFT OUTER JOIN的结果会增加一行，对应的`class_name`是`NULL`

right join:

解释：RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以`NULL`填充剩下的字段。



#### 雪花算法生成ID

1) 1位，不用。二进制中最高位为1的都是负数，但是我们生成的id一般都使用整数，所以这个最高位固定是0
2) 41位，用来记录时间戳（毫秒）。
3) 41位可以表示2^41−1个数字，如果只用来表示正整数（计算机中正数包含0），可以表示的数值范围是：0 至 2^41−1，减1是因为可表示的数值范围是从0开始算的，而不是1。
也就是说41位可以表示2^41−1个毫秒的值，转化成单位年则是(2^41−1)/(1000∗60∗60∗24∗365)=69年
4) 10位，用来记录工作机器id。
可以部署在2^10=1024个节点，包括5位datacenterId和5位workerId
5) 5位（bit）可以表示的最大正整数是2^5−1=31，即可以用0、1、2、3、....31这32个数字，来表示不同的datecenterId或workerId
6) 12位，序列号，用来记录同毫秒内产生的不同id。
12位（bit）可以表示的最大正整数是2^12−1=4095，即可以用0、1、2、3、....4094这4095个数字，来表示同一机器同一时间截（毫秒)内产生的4095个ID序号
由于在Java中64bit的整数是long类型，所以在Java中SnowFlake算法生成的id就是long来存储的。



##### 分页

1）Hibernate自带的分页机制

通过Session对象获取query对象，并调用query对象的setFirstResult()方法来设置要查询的第一行数据；最后用setMaxResults()方法来设置要查询结果集的大小

2）SQL语句

begin表示开始的行数，count表示查询的数据

```sql
select * from tableName where 条件 limit begin, count
```



#### Hash索引和BTree索引区别

不同的引擎对于索引有不同的支持：Innodb和MyISAM默认的索引是Btree索引；而Mermory默认的索引是Hash索引。

我们在mysql中常用两种索引算法BTree和Hash，两种算法检索方式不一样，对查询的作用也不一样。
一、BTree
BTree索引是最常用的mysql数据库索引算法，因为它不仅可以被用在=,>,>=,<,<=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量，例如：
select * from user where name like ‘jack%’;
select * from user where name like ‘jac%k%’;
如果一通配符开头，或者没有使用常量，则不会使用索引，例如：
select * from user where name like ‘%jack’;
select * from user where name like simply_name;
二、Hash
Hash索引只能用于对等比较，例如=,<=>（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。
但为什么我们使用BTree比使用Hash多呢？主要Hash本身由于其特殊性，也带来了很多限制和弊端：

1. Hash索引仅仅能满足“=”,“IN”,“<=>”查询，不能使用范围查询。
2. 联合索引中，Hash索引不能利用部分索引键查询。
   对于联合索引中的多个列，Hash是要么全部使用，要么全部不使用，并不支持BTree支持的联合索引的最优前缀，也就是联合索引的前面一个或几个索引键进行查询时，Hash索引无法被利用。
3. Hash索引无法避免数据的排序操作
   由于Hash索引中存放的是经过Hash计算之后的Hash值，而且Hash值的大小关系并不一定和Hash运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算。
4. Hash索引任何时候都不能避免表扫描
   Hash索引是将索引键通过Hash运算之后，将Hash运算结果的Hash值和所对应的行指针信息存放于一个Hash表中，由于不同索引键存在相同Hash值，所以即使满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要通过访问表中的实际数据进行比较，并得到相应的结果。
5. Hash索引遇到大量Hash值相等的情况后性能并不一定会比BTree高
   对于选择性比较低的索引键，如果创建Hash索引，那么将会存在大量记录指针信息存于同一个Hash值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据访问，而造成整体性能底下。

\1. hash索引查找数据基本上能一次定位数据，当然有大量碰撞的话性能也会下降。而btree索引就得在节点上挨着查找了，很明显在数据精确查找方面hash索引的效率是要高于btree的；
\2. 那么不精确查找呢，也很明显，因为hash算法是基于等值计算的，所以对于“like”等范围查找hash索引无效，不支持；
\3. 对于btree支持的[联合索引](https://www.baidu.com/s?wd=%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)的最优前缀，hash也是无法支持的，[联合索引](https://www.baidu.com/s?wd=%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)中的字段要么全用要么全不用。提起最优前缀居然都泛起迷糊了，看来有时候放空得太厉害；
\4. hash不支持索引排序，索引值和计算出来的hash值大小并不一定一致。



### 6. 程序设计

#### 栈溢出

栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致栈中与其相邻的变量的值被改变。

栈溢出的前提：

1. 程序必须向栈上写入数据。
2. 写入的数据大小没有被良好地控制。





### 摩根电面

##### self intro

##### ten Questions

1) normal sorting

2) heap sort

3) reference

4) virtual function

5) abstract  class

6) stack overflow

7) several types of join in sql

8) index

9) deadlock

10) SQL injection

##### Talk about Projects

##### Q&A


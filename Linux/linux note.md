## 常用配置

### ssh免密登陆

- 在本地生成rsa公钥

```bash
ssh-keygen

```

- 远程服务器创建ssh目录(if not exsits)

mkdir -p ~/.ssh *//-p选项表示遇到不存在的目录自动创建*

- 将本地创建的ssh公钥放到服务器上

```bash
scp ~/.ssh/id_rsa.pub lixiuwen.xwl@10.227.9.11:~/.ssh/

```

- 将服务器上的公钥id_rsa.pub的内容复制到服务器~/.ssh/authorized_keys中

```bash
cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys

```

- 修改`authorized_keys`文件权限

```bash
chmod 600 ~/.ssh/authorized_keys
```

- 在本地创建登陆配置文件

```bash
#编辑/etc/hosts文件
10.227.9.11 	devbox
```

- 通过别名登陆

```bash
ssh lixiuwen.xwl@devbox
```





## 安装应用

### pip

#### Linux

- 通过脚本安装

```bash
curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py
python get-pip.py
```



- 通过Linux软件包安装

```bash
#Debian/Ubuntu
#Python 2:
sudo apt install python-pip
#Python 3:
sudo apt install python3-venv python3-pip
```



- 更新pip

```bash
sudo pip3 install -U pip

```



- 卸载pip

```bash
sudo python -m pip uninstall pip
```



#### Mac

- 命令行输入

```bash
sudo easy_install pip
```


pip --version查看版本信息



- 卸载

```bash
sudo pip uninstall pip 
```







## 常用指令

### 权限

- chmod 

```bash
chmod [ugoa...][[+-=][rwxX]...][,...]
```

- u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。
- \+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。
- r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。

例：

1. 将文件 file1.txt 设为所有人皆可读取 :

```bash
chmod ugo+r file1.txt
```

2. 将文件 file1.txt 设为所有人皆可读取 :

```bash
chmod a+r file1.txt
```

3. 将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :

```bash
chmod ug+w,o-w file1.txt file2.txt
```



此外也可以用数字表示权限

语法为：

```
chmod abc file
```

其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。

r=4，w=2，x=1

- 若要rwx属性则4+2+1=7；
- 若要rw-属性则4+2=6；
- 若要r-x属性则4+1=5。

```bash
chmod 777 file		# equels chmod a=rwx file
```

*注意要指定file是当前目录的文件，否则系统会去PATH里寻找file.sh的



### 文件

#### 增删查改

- 复制整个文件夹

```bash
cp -r dir1 dir2
```

- 删除整个文件夹

```bash
rm -rf dir
```

- 移动

```bash
mv src_dir dest_dir
```





#### 链接

- 软连接

```bash
sudo ln -s /usr/bin/python2.7 /usr/bin/python		
```





#### 远程下载

```bash
wget url
```



- 指定目录下载

```bash
wget url -P dir
```



- 指定文件名下载

```bash
wget -O <filename> http://www.baidu.com/index.html
```



#### 打包压缩

语法：

```SHELL
tar [选项] 压缩包 源文件或目录
```



| 选项    | 含义                                                         |
| ------- | ------------------------------------------------------------ |
| -c      | 将多个文件或目录进行打包。                                   |
| -A      | 追加 tar 文件到归档文件。                                    |
| -f 包名 | 指定包的文件名。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名； |
| -v      | 显示打包文件过程；                                           |
| -x      | 对 tar 包做解打包操作                                        |
| -t      | 只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作。   |

解打包和打包相比，只是把打包选项 "-cvf" 更换为 "-xvf"



压缩：

- -z：压缩和解压缩 ".tar.gz" 格式；
- -j：压缩和解压缩 ".tar.bz2"格式。

```shell
tar -zcvf tmp.tar.gz /temp/
#把/temp/目录直接打包压缩为".tar.gz"格式，通过"-z"来识别格式，"-cvf"和打包选项一致
```



```bash
tar -zxvf tmp.tar.gz
#解压缩与解打包".tar.gz"格式
```



"-C" 用于指定解压位置、"-t" 用于查看压缩包内容

【例 2】压缩与解压缩 ".tar.bz2" 格式。

```shell
tar -jcvf tmp.tar.bz2 /tmp/
#打包压缩为".tar.bz2"格式，注意压缩包文件名

tar -jxvf tmp.tar.bz2
#解压缩与解打包".tar.bz2"格式
```



#### 图片

- 查看图片尺寸等信息

```shell
apt-get install imagemagick

identify p.jpg 
```





### 文本

#### 重定向

**输入重定向**

| 命令符号格式           | 作用                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 命令 < 文件            | 将指定文件作为命令的输入设备                                 |
| 命令 << 分界符         | 表示从标准输入设备（键盘）中读入，直到遇到分界符才停止（读入的数据不包括分界符），这里的分界符其实就是自定义的字符串 |
| 命令 < 文件 1 > 文件 2 | 将文件 1 作为命令的输入设备，该命令的执行结果输出到文件 2 中。 |



```shell
cat < /etc/passwd > a.txt
```





**输出重定向**

输出重定向还可以细分为标准输出重定向和错误输出重定向两种技术。

| 命令符号格式                         | 作用                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| 命令 > 文件                          | 将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，会清空原有数据，再写入新数据。 |
| 命令 2> 文件                         | 将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，会清空原有数据，再写入新数据。 |
| 命令 >> 文件                         | 将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，新数据将写入到原有内容的后面。 |
| 命令 2>> 文件                        | 将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，新数据将写入到原有内容的后面。 |
| 命令 >> 文件 2>&1 或者 命令 &>> 文件 | 将标准输出或者错误输出写入到指定文件，如果该文件中已包含数据，新数据将写入到原有内容的后面。注意，第一种格式中，最后的 2>&1 是一体的，可以认为是固定写法。 |

```shell
[root@localhost ~] cat Linux.txt > demo.txt
[root@localhost ~] cat demo.txt
Linux
[root@localhost ~] cat Linux.txt > demo.txt
[root@localhost ~] cat demo.txt
Linux     <--这里的 Linux 是清空原有的 Linux 之后，写入的新的 Linux
[root@localhost ~] cat Linux.txt >> demo.txt
[root@localhost ~] cat demo.txt
Linux
Linux     <--以追加的方式，新数据写入到原有数据之后
[root@localhost ~] cat b.txt > demo.txt
cat: b.txt: No such file or directory  <-- 错误输出信息依然输出到了显示器中
[root@localhost ~] cat b.txt 2> demo.txt
[root@localhost ~] cat demo.txt
cat: b.txt: No such file or directory  <--清空文件，再将错误输出信息写入到该文件中
[root@localhost ~] cat b.txt 2>> demo.txt
[root@localhost ~] cat demo.txt
cat: b.txt: No such file or directory
cat: b.txt: No such file or directory  <--追加写入错误输出信息
```



#### grep

通过正则表达式查找信息所在的行

语法：

```shell
grep [选项] 模式 文件名
```





| 通配符 | 功能                                                |
| ------ | --------------------------------------------------- |
| c*     | 将匹配 0 个（即空白）或多个字符 c（c 为任一字符）。 |
| .      | 将匹配任何一个字符，且只能是一个字符。              |
| [xyz]  | 匹配方括号中的任意一个字符。                        |
| [^xyz] | 匹配除方括号中字符外的所有字符。                    |
| ^      | 锁定行的开头。                                      |
| $      | 锁定行的结尾。                                      |



| 选项 | 含义                                                       |
| ---- | ---------------------------------------------------------- |
| -c   | 仅列出文件中包含模式的行数。                               |
| -i   | 忽略模式中的字母大小写。                                   |
| -l   | 列出带有匹配行的文件名。                                   |
| -n   | 在每一行的最前面列出行号。                                 |
| -v   | 列出没有匹配模式的行。                                     |
| -w   | 把表达式当做一个完整的单字符来搜寻，忽略那些部分匹配的行。 |





### 系统管理

查看系统版本信息

```shell
cat /proc/version
	
uname -a
```





启动进程的方式：1）手工启动；2）调度



#### ps

通过此命令可以查看系统中所有运行进程的详细信息。

```shell
ps [选项]
```

选项：

- a：显示一个终端的所有进程，除会话引线外；
- u：显示进程的归属用户及内存的使用情况；
- x：显示没有控制终端的进程；
- -l：长格式显示更加详细的信息；
- -e：显示所有进程；





| 表头    | 含义                                                         |
| ------- | ------------------------------------------------------------ |
| USER    | 该进程是由哪个用户产生的。                                   |
| PID     | 进程的 ID。                                                  |
| %CPU    | 该进程占用 CPU 资源的百分比，占用的百分比越高，进程越耗费资源。 |
| %MEM    | 该进程占用物理内存的百分比，占用的百分比越高，进程越耗费资源。 |
| VSZ     | 该进程占用虚拟内存的大小，单位为 KB。                        |
| RSS     | 该进程占用实际物理内存的大小，单位为 KB。                    |
| TTY     | 该进程是在哪个终端运行的。其中，tty1 ~ tty7 代表本地控制台终端（可以通过 Alt+F1 ~ F7 快捷键切换不同的终端），tty1~tty6 是本地的字符界面终端，tty7 是图形终端。pts/0 ~ 255 代表虚拟终端，一般是远程连接的终端，第一个远程连接占用 pts/0，第二个远程连接占用 pts/1，依次増长。 |
| STAT    | 进程状态。常见状态有以下几种：-D：不可被唤醒的睡眠状态，通常用于 I/O 情况。-R：该进程正在运行。-S：该进程处于睡眠状态，可被唤醒。-T：停止状态，可能是在后台暂停或进程处于除错状态。-W：内存交互状态（从 2.6 内核开始无效）。-X：死掉的进程（应该不会出现）。-Z：僵尸进程。进程已经中止，但是部分程序还在内存当中。-<：高优先级（以下状态在 BSD 格式中出现）。-N：低优先级。-L：被锁入内存。-s：包含子进程。-l：多线程（小写 L）。-+：位于后台。 |
| START   | 该进程的启动时间。                                           |
| TIME    | 该进程占用 CPU 的运算时间，注意不是系统时间。                |
| COMMAND | 产生此进程的命令名。                                         |



"ps -le"命令也能看到系统中所有的进程。由于 "-l" 选项的作用，所以 "ps -le" 命令能够看到更加详细的信息，比如父进程的 PID、优先级等。但是这两个命令的基本作用是一致的，掌握其中一个就足够了。

| 表头  | 含义                                                         |
| ----- | ------------------------------------------------------------ |
| F     | 进程标志，说明进程的权限，常见的标志有两个: 1：进程可以被复制，但是不能被执行；4：进程使用超级用户权限； |
| S     | 进程状态。具体的状态和"psaux"命令中的 STAT 状态一致；        |
| UID   | 运行此进程的用户的 ID；                                      |
| PID   | 进程的 ID；                                                  |
| PPID  | 父进程的 ID；                                                |
| C     | 该进程的 CPU 使用率，单位是百分比；                          |
| PRI   | 进程的优先级，数值越小，该进程的优先级越高，越早被 CPU 执行； |
| NI    | 进程的优先级，数值越小，该进程越早被执行；                   |
| ADDR  | 该进程在内存的哪个位置；                                     |
| SZ    | 该进程占用多大内存；                                         |
| WCHAN | 该进程是否运行。"-"代表正在运行；                            |
| TTY   | 该进程由哪个终端产生；                                       |
| TIME  | 该进程占用 CPU 的运算时间，注意不是系统时间；                |
| CMD   | 产生此进程的命令名；                                         |



#### top

```shell
top [选项]
```

选项：

- -d 秒数：指定 top 命令每隔几秒更新。默认是 3 秒；
- -b：使用批处理模式输出。一般和"-n"选项合用，用于把 top 命令重定向到文件中；
- -n 次数：指定 top 命令执行的次数。一般和"-"选项合用；
- -p 进程PID：仅查看指定 ID 的进程；
- -s：使 top 命令在安全模式中运行，避免在交互模式中出现错误；
- -u 用户名：只监听某个用户的进程；


在 top 命令的显示窗口中，还可以使用如下按键，进行一下交互操作：

- ? 或 h：显示交互模式的帮助；
- P：按照 CPU 的使用率排序，默认就是此选项；
- M：按照内存的使用率排序；
- N：按照 PID 排序；
- T：按照 CPU 的累积运算时间排序，也就是按照 TIME+ 项排序；
- k：按照 PID 给予某个进程一个信号。一般用于中止某个进程，信号 9 是强制中止的信号；
- r：按照 PID 给某个进程重设优先级（Nice）值；
- q：退出 top 命令；



#### nvidia-smi

查看显存的使用情况

表头释义：

-   Fan：显示风扇转速，数值在0到100%之间，是计算机的期望转速，如果计算机不是通过风扇冷却或者风扇坏了，显示出来就是N/A；
-   Temp：显卡内部的温度，单位是摄氏度；
-   Perf：表征性能状态，从P0到P12，P0表示最大性能，P12表示状态最小性能；
-   Pwr：能耗表示；
-   Bus-Id：涉及GPU总线的相关信息；
-   Disp.A：是Display Active的意思，表示GPU的显示是否初始化；
-   Memory Usage：显存的使用率；
-   Volatile GPU-Util：浮动的GPU利用率；
-   Compute M：计算模式；

下边的Processes显示每块GPU上每个进程所使用的显存情况。

如果要周期性的输出显卡的使用情况，可以用watch指令实现：

 ```shell
watch -n 10 nvidia-smi
 ```

命令行参数-n后边跟的是执行命令的周期，以s为单位。





#### pstree

打印进程树

```shell
pstree [选项] [PID或用户名]
```

选项：

| 选项 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| -a   | 显示启动每个进程对应的完整指令，包括启动进程的路径、参数等。 |
| -c   | 不使用精简法显示进程信息，即显示的进程中包含子进程和父进程。 |
| -n   | 根据进程 PID 号来排序输出，默认是以程序名排序输出的。        |
| -p   | 显示进程的 PID。                                             |
| -u   | 显示进程对应的用户名称。                                     |

#### lsof

```shell
lsof [选项]
```

| 选项      | 功能                                 |
| --------- | ------------------------------------ |
| -c 字符串 | 只列出以字符串开头的进程打开的文件。 |
| +d 目录名 | 列出某个目录中所有被进程调用的文件。 |
| -u 用户名 | 只列出某个用户的进程打开的文件。     |
| -p pid    | 列出某个 PID 进程打开的文件。        |



**`-i`** 选项，可以列出网络连接情况。语法格式：

```shell
lsof -i[46] [protocol] [@hostname|hostaddr] [:service|port]

参数解析：
4/6：IPv4或IPv6
protocol：TCP或UDP
hostname：主机名
hostaddr：ip地址
service：/etc/service中服务名，可写多个
port：端口号，可写多个
```



#### 进程优先级

表示进程优先级的有两个参数：Priority（PR） 和 Nice（NI）。两个值都表示优先级，数值越小代表该进程越优先被 CPU 处理。

ps -le命令可查看这两个参数



**nice**

nice 命令可以给要启动的进程赋予 NI 值，但是不能修改已运行进程的 NI 值。

```shell
nice [-n NI值] 命令		#该值的范围为 -20~19；

nice -n -5 service httpd start
```



**renice**

renice 命令可以在进程运行时修改其 NI 值，从而调整优先级。

```shell
renice [优先级] PID

renice -10 2125
```





#### kill

进程的管理主要是指进程的关闭与重启。我们一般关闭或重启软件，都是关闭或重启它的程序，而不是直接操作进程的。比如，要重启 apache 服务，一般使用命令"service httpd restart"重启 apache的程序。此时要依赖进程的信号。

使用命令"kill -l"或"man 7 signal"来查询系统的进程信号

| 代号 | 信号名称 | 说 明                                                        |
| ---- | -------- | ------------------------------------------------------------ |
| 1    | SIGHUP   | 该信号让进程立即关闭.然后重新读取配置文件之后重启            |
| 2    | SIGINT   | 程序中止信号，用于中止前台进程。相当于输出 Ctrl+C 快捷键     |
| 8    | SIGFPE   | 在发生致命的算术运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为 0 等其他所有的算术运算错误 |
| 9    | SIGKILL  | 用来立即结束程序的运行。本信号不能被阻塞、处理和忽略。般用于强制中止进程 |
| 14   | SIGALRM  | 时钟定时信号，计算的是实际的时间或时钟时间。alarm 函数使用该信号 |
| 15   | SIGTERM  | 正常结束进程的信号，kill 命令的默认信号。如果进程已经发生了问题，那么这 个信号是无法正常中止进程的，这时我们才会尝试 SIGKILL 信号，也就是信号 9 |
| 18   | SIGCONT  | 该信号可以让暂停的进程恢复执行。本信号不能被阻断             |
| 19   | SIGSTOP  | 该信号可以暂停前台进程，相当于输入 Ctrl+Z 快捷键。本信号不能被阻断 |



选项

- -l 信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称

- -a 当处理当前进程时，不限制命令名和进程号的对应关系

- -p 指定kill 命令只打印相关进程的进程号，而不发送任何信号

- -s 指定发送信号

- -u 指定用户 





**killall**

```shell
killall [选项] [信号] 进程名

killall -i sshd
```

- -i：交互式，询问是否要杀死某个进程；
- -I：忽略进程名的大小写；



**pkill**

1. 当作于管理进程时，pkill 命令和 killall 命令的用法相同。



2. 还有一个更重要的功能，即按照终端号来踢出用户登录。

```shell
pkill [-t 终端号] 进程名


[root@localhost ~]$ w
#使用w命令查询本机已经登录的用户
20:06:34 up 28 min, 3 users, load average: 0.00, 0.00, 0.00
USER  TTY           FROM LOGIN@  IDLE  JCPU  PCPU WHAT
root ttyl              -  19:47 18:52 0.01s 0.01s -bash
root pts/0 192.168.0.100  19:47 0.00s 0.09s 0.04s w
root pts/1 192.168.0.100  19:51 14:56 0.02s 0.02s -bash

[root@localhost ~]$ pkill -9 -t pts/1		
#强制杀死从pts/1虚拟终端登陆的进程
```





#### 后台运行

1. 在命令后面加入 `空格 &`。使用这种方法放入后台的命令，在后台处于执行状态。
2. 命令执行过程中按ctrl+z快捷键，命令在后台处于暂停状态





- 查看终端放入后台的工作

```shell
jobs [选项]

[root@localhost ~]#jobs -l
[1]- 2023 Stopped top
[2]+ 2034 Stopped tar -zcf etc.tar.gz /etc
```

以看到，当前终端有两个后台工作：一个是 top 命令，工作号为 1，状态是暂停，标志是"-"；另一个是 tar 命令，工作号为 2，状态是暂停，标志是"+"。"+"号代表最近一个放入后台的工作，也是工作恢复时默认恢复的工作。"-"号代表倒数第二个放入后台的工作，而第三个以后的工作就没有"+-"标志了。



- 后台工作恢复到前台

```shell
fg %工作号
```



- 把后台工作恢复执行

使用 `Ctrl+Z` 快捷键的方式，可以将前台工作放入后台，但是会处于暂停状态，bg命令可以使后台工作继续在后台执行。

```shell
bg ％工作号
```

*如果是top这样只能在前台执行的命令，则还是会在后台保持stopped的状态



- 脱离终端运行

1. 需要在后台执行的命令加入 /etc/rc.local 文件，让系统在启动时执行这个后台程序。这种方法的问题是，服务器是不能随便重启的，如果有临时后台任务，就不能执行了。
2. 使用系统**定时任务**，让系统在指定的时间执行某个后台命令。这样放入后台的命令与终端无关，是不依赖登录终端的。
3. 使用 **nohup** 命令。

```shell
nohup [命令] &

#这里的‘&’表示此命令会在终端后台工作；反之，如果没有‘&’，则表示此命令会在终端前台工作。
```



#### free

查看内存使用情况

```shell
free [选项]
```

| 选项        | 含义                                                         |
| ----------- | ------------------------------------------------------------ |
| -b          | 以 Byte（字节）为单位，显示内存使用情况。                    |
| -k          | 以 KB 为单位，显示内存使用情况，此选项是 free 命令的默认选项。 |
| -m          | 以 MB 为单位，显示内存使用情况。                             |
| -g          | 以 GB 为单位，显示内存使用情况。                             |
| -t          | 在输出的最终结果中，输出内存和 swap 分区的总量。             |
| -o          | 不显示系统缓冲区这一列。                                     |
| -s 间隔秒数 | 根据指定的间隔时间，持续显示内存使用情况。                   |



第一行显示的是各个列的列表头信息，各自的含义如下所示：

- total 是总内存数；
- used 是已经使用的内存数；
- free 是空闲的内存数；
- shared 是多个进程共享的内存总数；
- buffers 是缓冲内存数；
- cached 是缓存内存数。



#### w who

使用 w 或 who 命令都可以查看服务器上目前已登录的用户信息，两者的区别在于，w 命令除了能知道目前已登陆的用户信息，还可以知道每个用户执行任务的情况。



```shell
w [选项] [用户名]
```



| 选项 | 含义                                            |
| ---- | ----------------------------------------------- |
| -h   | 不显示输出信息的标题                            |
| -l   | 用长格式输出                                    |
| -s   | 用短格式输出，不显示登陆时间，JCPU 和 PCPU 时间 |
| -V   | 显示版本信息                                    |



命令输出各标题含义

| 标题   | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| USER   | 登录到系统的用户。                                           |
| TTY    | 登录终端。                                                   |
| FROM   | 表示用户从哪里登陆进来，一般显示远程登陆主机的 IP 地址或者主机名。 |
| LOGIN@ | 用户登陆的日期和时间。                                       |
| IDLE   | 表示某个程序上次从终端开始执行到现在所持续的时间。           |
| JCPU   | 和该终端连接的所有进程占用的 CPU 运算时间。这个时间里并不包括过去的后台作业时间，但是包括当前正在运行的后台作业所占用的时间。 |
| PCPU   | 当前进程所占用的 CPU 运算时间。                              |
| WHAT   | 当前用户正在执行的进程名称和选项，换句话说，就是表示用户当前执行的是什么命令。 |





## 专用软件

### opencv

查看linux下的opencv安装库：

```sql
pkg-config opencv --libs
```

查看linux下的opencv安装版本：

```
pkg-config opencv --modversion
```

查看linux下的opencv安装路径：

```swift
sudo find / -iname "*opencv*"
```

在全盘上不区分大小写，搜索带有关键字opencv的所有文件及文件夹都会输出到终端，如果输出太长建议输出到txt文件里查看，如下：

```ruby
sudo find / -iname "*opencv*" > /home/ubuntu/Desktop/opencv_find.txt
```




#### 模型

##### OSI

物理层、数据链路层、网络层、传输层、对话层、表示层和应用层

第一层:物理层(Physical Layer)

规定通信设备的机械的、电气的、功能的和规程的特性，用以建立、维护和拆除物理链路连接。具体地讲，机械特性定了网络连接时所需接插件的规格尺寸、引脚数量和排列情况等;电气特性规定了在物理连接上传输bit流时线路上信号电平的大小、阻抗匹配、传输速率距离限制等;功能特性是指对各个信号先分配确切的信号含义，即定义了DTE和DCE之间各个线路的功能;规程特性定义了利用信号线进行bit流传输的一组操作规程，是指在物理连接的建立、维护、交换信息时，DTE和DCE双方在各电路上的动作系列。

在这一层，数据的单位称为比特(bit)。

物理层的主要设备:中继器、集线器、适配器。

第二层:数据链路层(DataLink Layer)

物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧(Frame)在信道上无差错的传输，并进行各电路上的动作系列。

数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括:物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。

在这一层，数据的单位称为帧(frame)。

主要设备:二层交换机、网桥。

第三层:网络层(Networklayer)

在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点，确保数据及时传送。网络层将数据链路层提供的帧组成数据包，包中封装有网络层包头，其中含有逻辑地址信息- -源站点和目的站点地址的网络地址。

如果你在谈论一个IP地址，那么你是在处理第3层的问题，这是”数据包”问题，而不是第2层的”帧”。IP是第3层问题的一部分，此外还有一些路由协议和地址解析协议(ARP)。有关路由的一切事情都在第3层处理。地址解析和路由是3层的重要目的。网络层还可以实现拥塞控制、网际互连等功能。

在这一层，数据的单位称为数据包(packet)。

网络层协议的代表包括:IP、IPX、RIP、ARP、RARP、OSPF等。

网络层主要设备:路由器

第四层:传输层(Transportlayer)

第4层的数据单元也称作处理信息的传输层(Transport layer)。但是，当你谈论TCP等具体的协议时又有特殊的叫法，TCP的数据单元称为段(segments)而UDP协议的数据单元称为”数据报(datagrams)”。这个层负责获取全部信息，因此，它必须跟踪数据单元碎片、乱序到达的数据包和其它在传输过程中可能发生的危险。第4层为上层提供端到端(最终用户到最终用户)的透明的、可靠的数据传输服务。所谓透明的传输是指在通信过程中传输层对上层屏蔽了通信传输系统的具体细节。

传输层协议的代表包括:TCP、UDP、SPX等。

第五层:会话层(Sessionlayer)

在会话层及以上的高层次中，数据传送的单位不再另外命名，统称为报文。会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。如服务器验证用户登录便是由会话层完成的。

第六层:表示层(Presentationlayer)

这一层主要解决用户信息的语法表示问题。它将欲交换的数据从适合于某一用户的抽象语法，转换为适合于OSI系统内部使用的传送语法。即提供格式化的表示和转换数据服务。数据的压缩和解压缩， 加密和解密等工作都由表示层负责。例如图像格式的显示，就是由位于表示层的协议来支持。

第七层:应用层(Application Layer)

应用层为操作系统或网络应用程序提供访问网络服务的接口。

应用层协议的代表包括:Telnet、FTP、HTTP、SNMP等。



应用层:提供用户与网络间的接口。----HTTP、FTP、SMTP

运输层:进程到进程间的数据传输。---TCP、UDP

网络层:主机到主机之间的数据传输。---IP、选路协议

数据链路层:相邻结点之间的数据传输。---PPP、以太网

物理层:在物理介质上传输比特流。

应用层---------PDU是报文(message)
传输层---------PDU是数据段(segment)
网络层---------PDU是数据报(datagram)
数据链路层-----PDU是数据帧(frame)
物理层---------PDU是比特(bit)



#### DNS域名解析

应用层中的两种软件：

1. 客户/服务器
2. P2P体系结构

域名结构：

```http
mail.cctv.com
(三级域名).(二级域名).(顶级域名)
```

域名服务器：

1. 根域名服务器：最高层次的服务器，当任意一个本地域名服务器无法对一个域名进行解析，就求助于根域名服务器。它告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询。
2. 顶级域名服务器(TLD)：管理其下的所有二级域名。收到DNS查询请求时，就给出相应的回答。
3. 权限域名服务器：负责一个区的域名服务器，当权限域名服务器不能给出最后查询的回答时，就会告诉发出查询请求的DNS客户，下一步应当找哪一个权限域名服务器。
4. 本地域名服务器：当一台主机发出DNS查询请求时，这个查询请求就会发报文给本地域名服务器。其距离用户比较近。
5. 为了提高域名服务器的可靠性，将数据复制到几个域名服务器存储。一个是主域名服务器，其他是辅助域名服务器。修改只能通过主域名服务器进行。



##### 域名解析过程：

1. 通过域名访问网页
2. 计算机会先将域名发送到一个解析域名的服务器上
   1. 在其上层有很多服务器，能解析各种各样的域名，比如有专门解析.org的，解析.com的，解析.net的。等等，最主要的有一个根域名服务器，
   2. 域名解析(在服务器上查找IP地址)的过程有两种算法，迭代查询，递归查询。一般是两种查询的结合
   3. 本机计算机找到其中一台解析域名的服务器(可能是.com)，如果没有找到对应的IP地址，那么就会去找根域名服务器，根域名服务器知道所有的子服务器，所以他肯定知道该域名所对应的IP地址在那个子服务器中，所以告诉第一次查询的服务器要他去另一台服务器上找，找到了，就将其返回给计算机，以后再有另一台计算机也通过这个域名访问，那么该服务器会有原来的域名IP地址的**缓存**，就不用去找根服务器了。



*主机向本地域名服务器的查询一般采用**递归查询**，本地域名服务器向根域名服务器的查询通常采用**迭代查询**。

案例：查询y.abc.com的IP地址。

- 主机向本地域名服务器dns.xyz.com递归查询
- 本地域名服务器采用迭代查询。先向一个根域名服务器查询。
- 根域名服务器告诉本地域名服务器，下一次应查询的顶级域名服务器dns.com的IP地址。
- 本地域名服务器向顶级域名服务器dns.com查询。
- 顶级域名服务器dns.com告诉本地域名服务器，一下次应查询的权限域名服务器dns.abc.com的IP。
- 本地域名服务器向权限域名服务器dns.abc.com查询。
- 权限域名服务器dns.abc.com告诉本地域名服务器，所查询的主机的IP。
- 本地域名服务器把查询结果告诉主机。





#### HTTP协议

##### 统一资源定位符URL

```http
http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#r_70732423
```

一个完整的URL包括：协议部分、域名部分、端口部分、虚拟目录部分、文件名部分、参数部分、锚部分

1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符

2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用

3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口

4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”

5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名

7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。

6.锚部分：HTTP请求不包括锚部分，从“#”开始到最后，都是锚部分。本例中的锚部分是“r_70732423“。锚部分也不是一个URL必须的部分。 
锚点作用：打开用户页面时滚动到该锚点位置。

例：

一个域名“www.baidu.com.”由4部分：第1部分“.”代表根服务器、第2部分“.com.”代表顶级域名服务器、第3部分“baidu.com.”代表域名所有者服务器、第4部分“www.baidu.com.”代表主机域名。



##### 超文本传输协议HTTP

作用：怎样向服务器请求文档、服务器怎么把文档传送给浏览器，通俗点讲，就是我们想服务器访问网页资源时，服务器如何把网页上的东西传给我们。

客户端向服务器：请求报文　　　　服务器向客户端：响应报文

什么意思呢？在通过URL访问你服务器时，就会发送一个请求报文，告诉服务器需要哪些东西，服务器知道后，返回一个响应报文给客户端，其中就会带有一些网页信息。就是通过这个来达到传送网页资源的目的，现在来具体看看，请求报文和响应报文的格式。

请求报文格式：

![img](https://images2015.cnblogs.com/blog/874710/201612/874710-20161204145318443-858755785.png)

请求报文：

![img](https://images2015.cnblogs.com/blog/874710/201612/874710-20161204143934162-589996618.png)

请求头：

1、GET：请求的方式

2、Host：主机名 www.solu.com　　　　　　

3、User-Agent：使用什么代理服务器，这里就是FireFox，也就是火狐

4、Accept：能接收的数据类型有哪些

5、Accept-Language：表示用户希望优先想得到的版本，一次排列下去，先是中文，再是英文

6、Accept-Encoding：通知服务端可以发送的数据压缩格式

7、Cookie：浏览器端的一个技术，在服务器上记录用户信息，但是也会在浏览器中保存一份。

8、Connection：连接的方式，有两种，非持续连接和持续连接，非持续连接，一次请求/响应就对应一个TCP连接，接到了响应该连接就关闭，然后在发送请求就在建立TCP连接，持续连接就相反，这里使用的是持续连接

9、Upgrade-Insecure-Requests：该指令用于让浏览器自动升级请求从http到https,用于大量包含http资源的http网页直接升级到https而不会报错.简洁的来讲,就相当于在http和https之间起的一个过渡作用（了解即可）



##### 状态码：

- 1xx：表示通知信息的，比如请求收到了或正在进行处理
- 2xx：表示成功，也就是服务器接收到了你的请求，并成功处理了，一般最喜欢看到的就是200了
- 3xx：表示重定向，服务器告诉浏览器要完成请求你必须采取进一步的行动，也就是去访问另一个网页，
- 4xx：表示客户的差错，比如请求中有错误的语法或不能完成
  - 400错误：Bad request。提交的参数与后端不符或前端没将后端所传的json数据转化为字符串。
  - 404错误：就是找不到资源，就是你的URL写的有错误，使定位不到正确的资源
  - 405：方法不被允许，访问了不该访问的资源。
- 5xx：服务器的差错，如服务器失效，或者内部出现异常不能完成你的请求
  - 500：就是服务器写的代码中有问题。
  - 502：bad gateway，网关错误。后端不可响应或响应超时(mysql过慢等)
  - 503：HTTP服务器正常，只是下层web服务服务不能正常工作。最可能的原因是资源不足：服务器突然收到太多请求，以至于无法全部处理。
  - 504：被请求服务器发送超时引起。

##### HTTP&HTTPS：

Https：是以安全为目标的Http通道，是Http的安全版。Https的安全基础是SSL。SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层：SSL记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL握手协议（SSL Handshake Protocol），它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。

区别：

1、https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。(原来网易官网是http，而网易邮箱是https。)

2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

4、http的连接很简单，是无状态的。Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

HTTPS优点：

1、使用Https协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。

2、Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。

3、Https是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

HTTPS缺点：

1、Https协议握手阶段比较费时，会使页面的加载时间延长近。

2、Https连接缓存不如Http高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响；

3、SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。

4、Https协议的加密范围也比较有限。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。

##### 从输入URL到页面展示的详细过程

- 1、输入网址
- 2、DNS解析
- 3、建立tcp连接
- 4、客户端发送HTTP请求
- 5、服务器处理请求
- 6、服务器响应请求
- 7、浏览器展示HTML
- 8、浏览器发送请求获取其他在HTML中的资源。

##### Session&Cookie

由于http的无状态性，为了使某个域名下的所有网页能够共享某些数据，session和cookie出现了。客户端访问服务器的流程如下

- 首先，客户端会发送一个http请求到服务器端。
- 服务器端接受客户端请求后，建立一个session，并发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。该头部包含了sessionId。Set-Cookie格式如下，具体请看[Cookie详解](http://bubkoo.com/2014/04/21/http-cookies-explained/)
  `Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]`
- 在客户端发起的第二次请求，假如服务器给了set-Cookie，浏览器会自动在请求头中添加cookie
- 服务器接收请求，分解cookie，验证信息，核对成功后返回response给客户端

![è¯·æ±æµç¨](https://segmentfault.com/img/bVbmYbQ?w=400&h=200)

**注意**

- cookie只是实现session的其中一种方案。虽然是最常用的，但并不是唯一的方法。禁用cookie后还有其他方法存储，比如放在url中
- 现在大多都是Session + Cookie，但是只用session不用cookie，或是只用cookie，不用session在理论上都可以保持会话状态。可是实际中因为多种原因，一般不会单独使用
- 用session只需要在客户端保存一个id，实际上大量数据都是保存在服务端。如果全部用cookie，数据量大的时候客户端是没有那么多空间的。
- 如果只用cookie不用session，那么账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露。并且客户端数据量变大，网络传输的数据量也会变大



##### HTTP版本区别

**http1.0和http1.1的主要变化**：
首先是提出了长连接，http请求可以在一次tcp连接中不断发送。

然后是http1.1支持只发送header而不发送body。原因是先用header判断能否成功，再发数据，节约带宽，事实上，post请求默认就是这样做的。

http1.1的host字段。由于虚拟主机可以支持多个域名，所以一般将域名解析后得到host。

**http1.0和http2.0的区别**

http支持多路复用，同一个连接可以并发处理多个请求，方法是把http数据包拆为多个帧，并发有序的发送，根据序号在另一端进行重组，而不需要一个个http请求顺序到达。

http2.0支持服务端推送，就是服务端在http请求到达后，除了返回数据之外，还推送了额外的内容给客户端。

HTTP2.0压缩了请求头，同时基本单位是二进制帧流，这样的数据占用空间更少。

http2.0只适用于https场景，因为其在http和tcp中间加了一层ssl层。



##### 长连接和短连接

  HTTP1.1规定了默认保持长连接（HTTP persistent connection ，也有翻译为持久连接），数据传输完成了保持TCP连接不断开（不发RST包、不四次握手），等待在同域名下继续用这个通道传输数据；相反的就是短连接。

　HTTP首部的Connection: Keep-alive是HTTP1.0浏览器和服务器的实验性扩展，当前的HTTP1.1 RFC2616文档没有对它做说明，因为它所需要的功能已经默认开启，无须带着它，但是实践中可以发现，浏览器的报文请求都会带上它。如果HTTP1.1版本的HTTP请求报文不希望使用长连接，则要在HTTP请求报文首部加上Connection: close。